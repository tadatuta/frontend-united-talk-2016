заиспользовать
    http://tadatuta.github.io/yglf-2015-talk/#19

* file system organisation

* DOM abstraction
    BEM TREE -> BEMJSON

* declarative templates and JavaScript
    BEMHTML

* JS

* autogenerated documentation

* component-based test suits

=== БЭМ не про CSS ===

We believe BEM is like WebComponents… but better ;)

Interface is about components. We call them blocks.

[на слайде типичный лендинг и у него анатомия (блоки, все такое)]

Blocks may have quite huge structure and as so we need expressive means for it.
That's why we also have elements. They are inner parts (сравнить с shadow DOM).

Some blocks may look or behave differently. We use modifiers to convey such differences in appearence or state (React state).

[примеры, в т.ч. котики]

Таким образом у нас есть три термина блок, элемент, модификатор, которые позволяют описать интерфейс любой сложности. Мы очень много используем эту абстракцию и она оказалась очень удачной и удобной.

Блоки независимые и хранят знание о себе во всех технологиях внутри себя (аналогично web components).

```
blocks/
    button/
        button.css
        button.js
        button.spec.js
        button.md

```

Нужно выражать это в коде в виде дерева (BEM tree).

Для этого можно использовать XML или JSON. Мы будем использовать JS.

```js
{
    block: 'page',
    content: [
        { block: 'header' },
        { block: 'main' },
        { block: 'sidebar' },
        { block: 'footer' }
    ]
}
```

BTW, mixes

Такой формат мы называем BEMJSON.

Из такого представления интерфейса вытекает 2 задачи:
1. Получить из дерева HTML (BEMHTML)
    - из одного дерева разная разметка
    - декларативно (сравнение с CSS)
        подробно, как для Гарри Робертса

        .button {
            ...
        }

        block('button')(
            ...
        )

2. Собственно получить такое дерево из данных (DB, API, etc) (BEMTREE)
    Трехзвенная архитектура — это хорошо.
    С друпалом матчится, например, так. Или эдак.


Такая декларативная шаблонизация позволяет хранить шаблоны аналогично стилям в папке с блоком:

```
blocks/
    button/
        button.css
        button.js
        button.spec.js
        button.md
        button.bemhtml.js <-- here it is

```

Можно переопределять. Это уровни переопределения. Например, по платформам. Например, по библиотека VS проект.
Пример с CSS:

```
library/
    button/
        button.css
            .button {
                width: 200px;
                --color: green;--
            }

project/
    button/
        button.css
            .button {
                color: red;
            }
```

@import library/blocks/button/button.css;
@import project/blocks/button/button.css;

Аналогично с шаблонами.

// library/blocks/button/button.bemhtml.js
block('button')(
    tag()('button'),
    attrs()({
        type: 'submit'
    })
);

// project/blocks/button/button.bemhtml.js
block('button')(
    attrs()({
        type: 'reset'
    })
);

И теперь, когда мы узнали, что есть уровни, мы хотим аналогично и для JS.
    Скопипастить из http://tadatuta.github.io/dump-talk-2016/?full#section-5


Имея такие технологии и возмоности для реиспользования логично делать библиотеку.

Их есть у нас.

https://github.com/bem/bem-components/tree/v3/common.blocks
https://en.bem.info/libs/bem-components/

Тесты вот https://travis-ci.org/bem/bem-components

Как все это вместе?

project-stub
    сборка
        декларации, депсы

